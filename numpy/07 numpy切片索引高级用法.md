### 07. numpy切片索引高级用法

#### 切片索引
ndarray的切片语法跟Python列表这样的一维对象差不多：
```python
arr
Output: array([0, 1, 2, 3, 4, 64, 64, 64, 8, 9 ])

arr[1:6]
Output: array([1, 2, 3, 4, 64])
```
对于之前的二维数组arr2d，其切片方式稍显不同：
```python
arr2d
Output: array([[1, 2, 3], 
                [4, 5, 6],
                [7, 8, 9]])

arr2d[:2]
Output: array([[1, 2, 3],
                [4, 5, 6]])
```
可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。
表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。
你可以一次传入多个切片，就像传入多个索引那样：
```python
arr2d[:2, 1:]
Output:array([[2, 3],
            [5, 6]])
```
像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度
的切片。
例如，我可以选取第二行的前两列：
```python
arr2d[1, :2]
Output: array([4, 5])
```

#### 布尔型索引
来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复
项）。在这里，我将使用`numpy.random`中的`randn`函数生成一些正态分布的随机数据：
```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np.random.randn(7, 4)

names
Output: array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
dtype='S')

data
Output: array([[ 0.0929, 0.2817, 0.769 , 1.2464],
                [ 1.0072, -1.2962, 0.275 , 0.2289],
                [ 1.3529, 0.8864, -2.0016, -0.3718],
                [ 1.669 , -0.4386, -0.5397, 0.477 ],
                [ 3.2489, -1.0212, -0.5771, 0.1241],
                [ 0.3026, 0.5238, 0.0009, 1.3438],
                [-0.7135, -0.8312, -2.3702, -1.8608]])
```
假设每个名字都对应data数组中的一行，而我们想要选出对应于名字"Bob"的所有行。跟算术运算
一样，数组的比较运算（如==）也是矢量化的。因此，对names和字符串"Bob"的比较运算将会产
生一个布尔型数组：
```python
names == 'Bob'
array([ True, False, False, True, False, False, False], dtype=bool)
```
这个布尔型数组可用于数组索引：
```python
data[names == 'Bob']
Output: array([[ 0.0929, 0.2817, 0.769 , 1.2464],
                [ 1.669 , -0.4386, -0.5397, 0.477 ]])
```
```
注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。
```
下面的例子，我选取了 names == 'Bob' 的行，并索引了列：
```python
data[names == 'Bob', 2:]
Output: array([[ 0.769 , 1.2464],
                [-0.5397, 0.477 ]])
```
要选择除"Bob"以外的其他值，既可以使用不等于符号（`!=`），也可以通过`~`对条件进行否定：
```python
data[~(names == 'Bob')]
Output:array([[ 1.0072, -1.2962, 0.275 , 0.2289],
                [ 1.3529, 0.8864, -2.0016, -0.3718],
                [ 3.2489, -1.0212, -0.5771, 0.1241],
                [ 0.3026, 0.5238, 0.0009, 1.3438],
                [-0.7135, -0.8312, -2.3702, -1.8608]])
```
~操作符用来反转条件很好用：
```python
cond = names == 'Bob'
data[~cond]
Output: array([[ 1.0072, -1.2962, 0.275 , 0.2289],
                [ 1.3529, 0.8864, -2.0016, -0.3718],
                [ 3.2489, -1.0212, -0.5771, 0.1241],
                [ 0.3026, 0.5238, 0.0009, 1.3438],
                [-0.7135, -0.8312, -2.3702, -1.8608]])
```
选取这三个名字中的两个需要组合应用多个布尔条件，使用`&`（和）、`|`（或）之类的布尔算术运算
符即可：
```python
mask = (names == 'Bob') | (names == 'Will')
mask
Output: array([ True, False, True, True, True, False, False], dtype=bool)

data[mask]
Output: array([[ 0.0929, 0.2817, 0.769 , 1.2464],
                [ 1.3529, 0.8864, -2.0016, -0.3718],
                [ 1.669 , -0.4386, -0.5397, 0.477 ],
                [ 3.2489, -1.0212, -0.5771, 0.1241]])
```
通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。
```
注意：Python关键字and和or在布尔型数组中无效。要使用&与|。
```
通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：
```python
data[data < 0] = 0
data
Output: array([[ 0.0929, 0.2817, 0.769 , 1.2464],
                [ 1.0072, 0. , 0.275 , 0.2289],
                [ 1.3529, 0.8864, 0. , 0. ],
                [ 1.669 , 0. , 0. , 0.477 ],
                [ 3.2489, 0. , 0. , 0.1241],
                [ 0.3026, 0.5238, 0.0009, 1.3438],
                [ 0. , 0. , 0. , 0. ]])
```
#### 花式索引
花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一
个8×4数组：
```python
arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr
Output: array([[ 0., 0., 0., 0.],
                [ 1., 1., 1., 1.],
                [ 2., 2., 2., 2.],
                [ 3., 3., 3., 3.],
                [ 4., 4., 4., 4.],
                [ 5., 5., 5., 5.],
                [ 6., 6., 6., 6.],
                [ 7., 7., 7., 7.]])
```
为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或`ndarray`即可：
```python
arr[[4, 3, 0, 6]]
Output:
array([[ 4., 4., 4., 4.],
        [ 3., 3., 3., 3.],
        [ 0., 0., 0., 0.],
        [ 6., 6., 6., 6.]])
```
这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行：
```python
arr[[-3, -5, -7]]
Output: 
array([[ 5., 5., 5., 5.],
        [ 3., 3., 3., 3.],
        [ 1., 1., 1., 1.]])
```
一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：
```python
arr = np.arange(32).reshape((8, 4))
arr
Output:array([[ 0, 1, 2, 3],
            [ 4, 5, 6, 7],
            [ 8, 9, 10, 11],
            [12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23],
            [24, 25, 26, 27],
            [28, 29, 30, 31]])

arr[[1, 5, 7, 2], [0, 3, 1, 2]]
Output: array([4, 23, 29, 10])
```
这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是
矩形区域的形式才对。下面是得到该结果的一个办法：
```python
arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
array([[ 4, 7, 5, 6],
        [20, 23, 21, 22],
        [28, 31, 29, 30],
        [ 8, 11, 9, 10]])
```
记住，花式索引跟切片不一样，它总是将数据复制到新数组中。